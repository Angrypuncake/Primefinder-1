
def prime_finder(n):
#This is an overly complicated method of finding prime numbers by using double pointers in a list and nested while loops.

#Create a list comprehension of numbers using range(2,n) given that each element is not divisible by 2 so we're only dealing with a list of odd numbers.

  primes = [x for x in range(2,n + 1) if x > 2 and x % 2 != 0]
  

#Create a leftpointer set to start of list at index 0, create a right pointer starting at an index of 1
  left_pointer = 0 
  right_pointer = 1
  print("Unfiltered list: {0} \n".format(primes))
  removal_count = 0 

  print("Starting filter")
  while right_pointer <= len(primes) - 1:
    left_pointer = 0 
    print("Start left_pointer {0}".format(left_pointer))
    while left_pointer < right_pointer:
  #if ele at right pointer is div by element at leftpointer, then list.remove(element) and use continue to repeat the conditional.
      print("Currently checking {0} with {1}".format(primes[right_pointer],primes[left_pointer]))
      if primes[right_pointer] % primes[left_pointer] == 0:
        print("length of list index = {0}".format(len(primes) - 1))
        print("Current right pointer is {0}".format(right_pointer))
        print("{0} is divisible by {1}".format(primes[right_pointer], primes[left_pointer]))
        print("Removing %d" %(primes[right_pointer]))
        primes.remove(primes[right_pointer])
        left_pointer = 0
        removal_count += 1
        print("New list {0}: iteration: {1}, new length: {2}".format(primes, removal_count, len(primes) - 1 ))
        if right_pointer > len(primes) - 1:
          break
        continue
      left_pointer += 1
#increment leftpointer by one to shift it to the right to check the same element with a different number.
      print("Current right pointer is {0} while left pointer is {1} and length list is {2}".format(right_pointer,left_pointer,len(primes) - 1))
#When left pointer reaches right pointer, the current element is not divisible by any numbers before it and therefore can stay in the list. Increment right pointer by one to view next element. 
    if right_pointer > len(primes) - 1:
      break
#The if statement above is to handle out of list index errors because everytime you remove an element, the list shortens by 1. For the final case, you would have the right_pointer < len(list) which generates an index error.
    right_pointer += 1 
    print("Added one to right pointer {0}".format(right_pointer))

  primes.insert(0,2)
  return primes



print(prime_finder(300))
